# Benchmark-plot screencast transcript

Hello everyone.

In this screencast I'm going to introduce the benchmark-plot library that can be used for quickly creating graphs from benchmarks.

Let me demonstrate the usage of benchmark-plot with a small example. Say we want to create an Array which contains all the elements of the original array in adjacent positions. 

Two very common ways of doing that would be to first use `Array#map` and then `Array#flatten` or directly use `Array#flat_map`.

``` ruby
require 'benchmark'

arr = [50,100,500,1000]
Benchmark.bm do |x|
  arr.each do |size|
    x.report("map.flatten") do
      (1..size).to_a.map {|e| [e,e]}.flatten
    end

    x.report("flat_map") do
      (1..size).to_a.flat_map {|e| [e,e]}
    end
  end
end
```

Now, if you want to know the time taken by these methods for working on the same `Array`, you'll probably write a benchmarking script which looks something like this, where you send the sizes of your `Array`s into the benchmarking code, which then prepares the array and performs the benchmarking.

The problem with this approach is that it will produce an output which looks like this, which can quickly get out of hand once your benchmarking scripts or number of inputs increase.

An obvious solution is to plot the benchmarks on a graph, so they can be visualized easily. This is where [benchmark-plot](https://rubygems.org/gems/benchmark-plot) comes into the picture.

Benchmark-plot introduces a single method `.plot` into the `Benchmark` module. The plot method accepts any `Enumerable` object. In this example, I'm passing an `Array` of sizes into the method.
``` ruby
require 'benchmark/plot'

arr = [100, 500, 1000, 5000]
Benchmark.plot(arr) do |x|
  x.report("map.flatten") do |size|
    (1..size).to_a.map { |e| [e,e] }.flatten
  end

  x.report("flat_map") do |size|
    (1..size).to_a.flat_map { |e| [e,e] }
  end
end
```

As you can see, it yields an object in it's block, on which you can call the `#report` method. The `#report` method in turn yields the objects inside the object passed to the plot method one by one, each time running the code in the `#report` block and saving the results of the benchmarking for plotting. Running this code will produce a graph which looks something like this.

Now lets take a little more complex example, where we create the Arrays before sending them into the actual benchmarking script in the report method, so that the actual creation of the `Array` is not recorded in the benchmarks. For this purpose, let's map Array `arr` and populate it with subarrays of that size. A simple modification to the above script will lead to a script looking like this:
``` ruby
require 'benchmark/plot'

arr = [100, 500, 1000, 5000]
arr.map! { |s| (1..s).to_a }
Benchmark.plot(arr) do |x|
  x.report("map.flatten") do |a|
    a.map { |e| [e,e] }.flatten
  end

  x.report("flat_map") do |a|
    a.flat_map { |e| [e,e] }
  end
end
```

But when you run this code, the output you get ends up looking like this. The reason for this is that the X axis labels are populated by calling the `#to_s` method on the object, which leads to confusion when plotting.

To get over this, let's write a simple class that accepts an `Array` object and whose `#to_s` method outputs the size of that array. Let's call this class `TestArray`, and design it such that it stores the array in an instance variable called `@data` and it's `#to_s` method returns the size of the `Array`.
``` ruby
require 'benchmark/plot'

class TestArray
  attr_reader :data

  def initialize d
    @data = d
  end

  def to_s
    @data.size.to_s
  end
end

arr = [100, 500, 1000, 5000]
arr.map! { |s| TestArray.new (1..s).to_a }
Benchmark.plot(arr) do |x|
  x.report("map.flatten") do |a|
    a.map { |e| [e,e] }.flatten
  end

  x.report("flat_map") do |a|
    a.flat_map { |e| [e,e] }
  end
end
```

Let's run this code and see the output. As you can see, this is exactly what we need.

In addition to this, the graph that is generated by the plot method can be customized with these options. `:title` let's you change the heading of the graph, `:x_labels` toggles whether the labels of the X axis are visible or not, `:x_axis_label` let's you pass a string that can act as the label of the X axis of the graph, `:time` decides what kind of time is plotted, that is, whether it's system CPU time, user CPU time or real time and `:file_name` decides the name of the file of the graph.

For further information, you can have a look at the benchmark-plot [repo on github](https://github.com/v0dro/benchmark-plot).

Thank you so much for seeing this screen cast!
